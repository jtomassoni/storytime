import { prisma } from "./prisma"

/**
 * Auto-generates categories from story tags and ensures they exist in the database.
 * Returns category IDs that should be assigned to the story.
 */
export async function getAutoGeneratedCategoryIds(story: {
  valuesTags: string[]
  topicTags: string[]
  cultureTags: string[]
  representationTags: string[]
  minAge: number | null
  maxAge: number | null
}): Promise<string[]> {
  const categoryIds: string[] = []

  // Helper to capitalize first letter
  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()

  // Generate categories from valuesTags (e.g., "kindness" -> "Kindness Stories")
  for (const valueTag of story.valuesTags) {
    if (!valueTag.trim()) continue
    
    const categoryName = `${capitalize(valueTag)} Stories`
    const category = await findOrCreateCategory({
      name: categoryName,
      description: `Stories about ${valueTag}`,
      autoGenerated: true,
      sourceTag: `value:${valueTag}`,
    })
    categoryIds.push(category.id)
  }

  // Generate categories from topicTags (e.g., "adventure" -> "Adventure Stories")
  for (const topicTag of story.topicTags) {
    if (!topicTag.trim()) continue
    
    const categoryName = `${capitalize(topicTag)} Stories`
    const category = await findOrCreateCategory({
      name: categoryName,
      description: `Stories about ${topicTag}`,
      autoGenerated: true,
      sourceTag: `topic:${topicTag}`,
    })
    categoryIds.push(category.id)
  }

  // Generate categories from cultureTags (e.g., "European" -> "European Stories")
  for (const cultureTag of story.cultureTags) {
    if (!cultureTag.trim()) continue
    
    const categoryName = `${capitalize(cultureTag)} Stories`
    const category = await findOrCreateCategory({
      name: categoryName,
      description: `Stories from ${cultureTag} culture`,
      autoGenerated: true,
      sourceTag: `culture:${cultureTag}`,
    })
    categoryIds.push(category.id)
  }

  // Generate age-based categories if age range is specified
  if (story.minAge !== null && story.maxAge !== null) {
    const ageCategoryName = `Ages ${story.minAge}-${story.maxAge}`
    const category = await findOrCreateCategory({
      name: ageCategoryName,
      description: `Stories for children ages ${story.minAge} to ${story.maxAge}`,
      minAge: story.minAge,
      maxAge: story.maxAge,
      autoGenerated: true,
      sourceTag: `age:${story.minAge}-${story.maxAge}`,
    })
    categoryIds.push(category.id)
  }

  // Generate gender-based categories from representation tags
  const hasBoy = story.representationTags.some(tag => 
    tag.toLowerCase().includes('boy protagonist')
  )
  const hasGirl = story.representationTags.some(tag => 
    tag.toLowerCase().includes('girl protagonist')
  )

  if (hasBoy && !hasGirl) {
    const category = await findOrCreateCategory({
      name: "Boy Protagonist Stories",
      description: "Stories featuring a boy as the main character",
      autoGenerated: true,
      sourceTag: "gender:boy",
    })
    categoryIds.push(category.id)
  } else if (hasGirl && !hasBoy) {
    const category = await findOrCreateCategory({
      name: "Girl Protagonist Stories",
      description: "Stories featuring a girl as the main character",
      autoGenerated: true,
      sourceTag: "gender:girl",
    })
    categoryIds.push(category.id)
  }

  return [...new Set(categoryIds)] // Remove duplicates
}

/**
 * Finds an existing category or creates a new one.
 * Uses sourceTag to identify auto-generated categories.
 */
async function findOrCreateCategory(data: {
  name: string
  description?: string
  minAge?: number | null
  maxAge?: number | null
  autoGenerated?: boolean
  sourceTag?: string
}) {
  // Try to find existing category by name first
  let category = await prisma.category.findFirst({
    where: { name: data.name },
  })

  if (!category) {
    // Create new category
    category = await prisma.category.create({
      data: {
        name: data.name,
        description: data.description || null,
        minAge: data.minAge || null,
        maxAge: data.maxAge || null,
        cultureTags: [],
        isAutoGenerated: data.autoGenerated || false,
        sourceTag: data.sourceTag || null,
      },
    })
  } else if (data.autoGenerated && !category.isAutoGenerated) {
    // Update existing category to mark as auto-generated if it wasn't before
    category = await prisma.category.update({
      where: { id: category.id },
      data: {
        isAutoGenerated: true,
        sourceTag: data.sourceTag || category.sourceTag,
      },
    })
  }

  return category
}

/**
 * Assigns a story to categories based on its tags.
 * This should be called whenever a story is created or updated.
 */
export async function assignStoryToAutoCategories(storyId: string) {
  const story = await prisma.story.findUnique({
    where: { id: storyId },
    select: {
      valuesTags: true,
      topicTags: true,
      cultureTags: true,
      representationTags: true,
      minAge: true,
      maxAge: true,
    },
  })

  if (!story) {
    throw new Error(`Story ${storyId} not found`)
  }

  // Get auto-generated category IDs
  const autoCategoryIds = await getAutoGeneratedCategoryIds(story)

  // Get existing category assignments
  const existingAssignments = await prisma.storyCategory.findMany({
    where: { storyId },
    select: { categoryId: true },
  })
  const existingCategoryIds = new Set(existingAssignments.map(a => a.categoryId))

  // Add auto-generated categories that aren't already assigned
  const newCategoryIds = autoCategoryIds.filter(id => !existingCategoryIds.has(id))

  if (newCategoryIds.length > 0) {
    await prisma.storyCategory.createMany({
      data: newCategoryIds.map(categoryId => ({
        storyId,
        categoryId,
      })),
      skipDuplicates: true,
    })
  }

  return { assigned: newCategoryIds.length, total: autoCategoryIds.length }
}

